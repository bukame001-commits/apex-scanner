<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>APEX SCANNER AI</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;500&display=swap');
  :root {
    --bg:#040a0f;--surface:#080f17;--card:#0a1520;--border:#0e2033;
    --accent:#00d4ff;--accent2:#00ff88;--warn:#ffb800;--danger:#ff3366;
    --text:#c8dde8;--muted:#4a6070;--strong:#ffffff;
  }
  *{margin:0;padding:0;box-sizing:border-box;}
  body{background:var(--bg);color:var(--text);font-family:'Inter',sans-serif;min-height:100vh;overflow-x:hidden;}
  body::before{content:'';position:fixed;inset:0;background-image:linear-gradient(rgba(0,212,255,0.03) 1px,transparent 1px),linear-gradient(90deg,rgba(0,212,255,0.03) 1px,transparent 1px);background-size:40px 40px;pointer-events:none;z-index:0;}
  .container{position:relative;z-index:1;max-width:900px;margin:0 auto;padding:20px 16px 60px;}
  .header{text-align:center;padding:30px 0 24px;}
  .header-badge{display:inline-block;font-family:'Share Tech Mono',monospace;font-size:10px;color:var(--accent);letter-spacing:4px;border:1px solid rgba(0,212,255,0.3);padding:4px 12px;margin-bottom:12px;animation:pulse-border 2s infinite;}
  @keyframes pulse-border{0%,100%{border-color:rgba(0,212,255,0.3);}50%{border-color:rgba(0,212,255,0.8);}}
  .header h1{font-family:'Orbitron',monospace;font-size:clamp(26px,7vw,46px);font-weight:900;color:var(--strong);letter-spacing:4px;text-shadow:0 0 40px rgba(0,212,255,0.4);}
  .header h1 span{color:var(--accent);}
  .header-sub{font-family:'Share Tech Mono',monospace;font-size:11px;color:var(--muted);letter-spacing:2px;margin-top:8px;}
  .section-label{font-family:'Share Tech Mono',monospace;font-size:10px;color:var(--accent);letter-spacing:3px;margin-bottom:10px;display:flex;align-items:center;gap:8px;}
  .section-label::after{content:'';flex:1;height:1px;background:linear-gradient(90deg,var(--border),transparent);}
  .card{background:var(--card);border:1px solid var(--border);border-radius:2px;padding:16px;margin-bottom:14px;position:relative;overflow:hidden;}
  .card::before{content:'';position:absolute;top:0;left:0;width:3px;height:100%;background:var(--accent);}

  /* AI Engine Selector */
  .engine-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  .engine-btn{background:var(--surface);border:2px solid var(--border);border-radius:2px;padding:14px;cursor:pointer;transition:all 0.15s;text-align:left;}
  .engine-btn:hover{border-color:var(--accent);}
  .engine-btn.active-claude{background:rgba(255,107,53,0.08);border-color:#ff6b35;}
  .engine-btn.active-gemini{background:rgba(0,212,255,0.08);border-color:var(--accent);}
  .engine-logo{font-size:24px;margin-bottom:6px;}
  .engine-name{font-family:'Orbitron',monospace;font-size:13px;font-weight:700;color:var(--strong);}
  .engine-name.claude{color:#ff6b35;}
  .engine-name.gemini{color:var(--accent);}
  .engine-desc{font-family:'Share Tech Mono',monospace;font-size:9px;color:var(--muted);margin-top:4px;line-height:1.5;}
  .engine-badge{display:inline-block;font-family:'Share Tech Mono',monospace;font-size:8px;padding:2px 6px;border-radius:2px;margin-top:6px;}
  .engine-badge.free{background:rgba(0,255,136,0.1);color:var(--accent2);border:1px solid rgba(0,255,136,0.3);}
  .engine-badge.paid{background:rgba(255,107,53,0.1);color:#ff6b35;border:1px solid rgba(255,107,53,0.3);}

  /* API inputs */
  .api-row{display:grid;grid-template-columns:1fr;gap:10px;}
  .api-field{display:none;}
  .api-field.visible{display:block;}
  .api-label{font-family:'Share Tech Mono',monospace;font-size:10px;color:var(--muted);margin-bottom:6px;letter-spacing:1px;}
  .api-input{width:100%;background:var(--surface);border:1px solid var(--border);border-radius:2px;padding:10px 14px;color:var(--text);font-family:'Share Tech Mono',monospace;font-size:12px;outline:none;transition:border-color 0.15s;}
  .api-input:focus{border-color:var(--accent);}
  .api-input::placeholder{color:var(--muted);}
  .api-actions{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap;}
  .api-clear-btn{font-family:'Share Tech Mono',monospace;font-size:9px;padding:5px 10px;background:transparent;border:1px solid var(--border);color:var(--muted);cursor:pointer;letter-spacing:1px;transition:all 0.15s;}
  .api-clear-btn:hover{border-color:var(--danger);color:var(--danger);}
  .api-note{font-family:'Share Tech Mono',monospace;font-size:9px;color:var(--muted);margin-top:8px;line-height:1.6;}
  .api-note a{color:var(--accent);text-decoration:none;}

  /* Markets */
  .market-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(130px,1fr));gap:8px;}
  .market-btn{background:var(--surface);border:1px solid var(--border);border-radius:2px;padding:10px 12px;cursor:pointer;transition:all 0.15s;font-family:'Share Tech Mono',monospace;font-size:11px;color:var(--muted);text-align:left;}
  .market-btn:hover{border-color:var(--accent);color:var(--accent);}
  .market-btn.active{background:rgba(0,212,255,0.08);border-color:var(--accent);color:var(--accent);}
  .market-btn .icon{font-size:16px;display:block;margin-bottom:4px;}
  .market-btn .name{font-size:11px;font-weight:700;}
  .market-btn .desc{font-size:9px;opacity:0.6;margin-top:2px;}

  /* Indicators */
  .ind-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:8px;}
  .ind-btn{background:var(--surface);border:1px solid var(--border);border-radius:2px;padding:10px 12px;cursor:pointer;transition:all 0.15s;font-family:'Share Tech Mono',monospace;font-size:11px;color:var(--muted);text-align:left;position:relative;}
  .ind-btn:hover{border-color:var(--accent2);color:var(--text);}
  .ind-btn.active{background:rgba(0,255,136,0.06);border-color:var(--accent2);color:var(--accent2);}
  .ind-btn .ind-name{font-size:12px;font-weight:700;}
  .ind-btn .ind-desc{font-size:9px;opacity:0.6;margin-top:3px;}
  .ind-check{position:absolute;top:8px;right:8px;width:14px;height:14px;border:1px solid currentColor;border-radius:2px;display:flex;align-items:center;justify-content:center;font-size:9px;}

  /* Sliders */
  .slider-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;}
  @media(max-width:500px){.slider-grid{grid-template-columns:1fr;}}
  .slider-item label{font-family:'Share Tech Mono',monospace;font-size:10px;color:var(--muted);display:block;margin-bottom:6px;}
  .slider-item label span{color:var(--accent);float:right;font-size:12px;}
  input[type=range]{-webkit-appearance:none;width:100%;height:2px;background:var(--border);outline:none;}
  input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;border-radius:2px;background:var(--accent);cursor:pointer;box-shadow:0 0 8px rgba(0,212,255,0.6);}

  /* Scan button */
  .scan-btn{width:100%;padding:18px;background:transparent;border:1px solid var(--accent);color:var(--accent);font-family:'Orbitron',monospace;font-size:14px;font-weight:700;letter-spacing:4px;cursor:pointer;position:relative;overflow:hidden;transition:all 0.2s;margin-top:6px;}
  .scan-btn::before{content:'';position:absolute;inset:0;background:linear-gradient(90deg,transparent,rgba(0,212,255,0.1),transparent);transform:translateX(-100%);transition:transform 0.4s;}
  .scan-btn:hover::before{transform:translateX(100%);}
  .scan-btn:hover{background:rgba(0,212,255,0.08);box-shadow:0 0 30px rgba(0,212,255,0.2);}
  .scan-btn:disabled{opacity:0.4;cursor:not-allowed;}

  /* Loading */
  .loading{display:none;text-align:center;padding:40px;font-family:'Share Tech Mono',monospace;font-size:12px;color:var(--accent);letter-spacing:2px;}
  .loading.visible{display:block;}
  .loading-bar{width:100%;height:2px;background:var(--border);margin:16px 0;position:relative;overflow:hidden;}
  .loading-bar::after{content:'';position:absolute;top:0;left:-40%;width:40%;height:100%;background:linear-gradient(90deg,transparent,var(--accent),transparent);animation:scan-line 1.2s infinite;}
  @keyframes scan-line{0%{left:-40%;}100%{left:100%;}}

  /* Results */
  .results-section{display:none;margin-top:20px;}
  .results-section.visible{display:block;}
  .results-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:14px;flex-wrap:wrap;gap:8px;}
  .results-stats{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:8px;margin-bottom:16px;}
  .stat-box{background:var(--card);border:1px solid var(--border);border-radius:2px;padding:10px 14px;text-align:center;}
  .stat-box .stat-val{font-family:'Orbitron',monospace;font-size:22px;font-weight:700;color:var(--accent);}
  .stat-box .stat-label{font-family:'Share Tech Mono',monospace;font-size:9px;color:var(--muted);letter-spacing:2px;margin-top:4px;}

  /* Alert cards */
  .alert-card{background:var(--card);border:1px solid var(--border);border-radius:2px;padding:14px 16px;margin-bottom:10px;position:relative;overflow:hidden;transition:border-color 0.15s;}
  .alert-card:hover{border-color:rgba(0,212,255,0.4);}
  .alert-card.strong::before{content:'';position:absolute;top:0;left:0;width:3px;height:100%;background:var(--accent2);}
  .alert-card.moderate::before{content:'';position:absolute;top:0;left:0;width:3px;height:100%;background:var(--warn);}
  .alert-top{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:8px;}
  .alert-symbol{font-family:'Orbitron',monospace;font-size:16px;font-weight:700;color:var(--strong);}
  .alert-market{font-family:'Share Tech Mono',monospace;font-size:9px;color:var(--muted);margin-top:2px;}
  .alert-score{font-family:'Orbitron',monospace;font-size:20px;font-weight:900;color:var(--accent2);}
  .alert-score.moderate{color:var(--warn);}
  .alert-signals{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px;}
  .signal-tag{font-family:'Share Tech Mono',monospace;font-size:10px;padding:3px 8px;border-radius:2px;border:1px solid;}
  .signal-tag.wt{color:var(--accent);border-color:rgba(0,212,255,0.4);background:rgba(0,212,255,0.06);}
  .signal-tag.rsi{color:#ff6b35;border-color:rgba(255,107,53,0.4);background:rgba(255,107,53,0.06);}
  .signal-tag.vol{color:var(--warn);border-color:rgba(255,184,0,0.4);background:rgba(255,184,0,0.06);}
  .signal-tag.bb{color:#a78bfa;border-color:rgba(167,139,250,0.4);background:rgba(167,139,250,0.06);}
  .signal-tag.macd{color:var(--accent2);border-color:rgba(0,255,136,0.4);background:rgba(0,255,136,0.06);}
  .signal-tag.other{color:var(--muted);border-color:var(--border);}
  .alert-analysis{font-size:12px;color:var(--text);line-height:1.6;border-top:1px solid var(--border);padding-top:8px;margin-top:4px;}
  .alert-values{display:flex;gap:16px;flex-wrap:wrap;margin-top:6px;}
  .alert-val{font-family:'Share Tech Mono',monospace;font-size:10px;color:var(--muted);}
  .alert-val span{color:var(--accent);}

  /* Filter */
  .filter-bar{display:flex;gap:8px;margin-bottom:14px;flex-wrap:wrap;}
  .filter-btn{font-family:'Share Tech Mono',monospace;font-size:10px;padding:6px 14px;border:1px solid var(--border);background:var(--surface);color:var(--muted);cursor:pointer;border-radius:2px;transition:all 0.15s;letter-spacing:1px;}
  .filter-btn:hover,.filter-btn.active{border-color:var(--accent);color:var(--accent);background:rgba(0,212,255,0.06);}

  /* AI Summary */
  .ai-summary{background:rgba(0,212,255,0.04);border:1px solid rgba(0,212,255,0.2);border-radius:2px;padding:16px;margin-bottom:16px;font-size:13px;line-height:1.8;color:var(--text);display:none;}
  .ai-summary.visible{display:block;}
  .ai-summary-title{font-family:'Orbitron',monospace;font-size:11px;color:var(--accent);letter-spacing:2px;margin-bottom:10px;}

  .new-scan-btn{background:transparent;border:1px solid var(--border);color:var(--muted);font-family:'Share Tech Mono',monospace;font-size:10px;padding:6px 14px;cursor:pointer;letter-spacing:2px;transition:all 0.15s;}
  .new-scan-btn:hover{border-color:var(--accent);color:var(--accent);}

  .toast{position:fixed;bottom:24px;left:50%;transform:translateX(-50%) translateY(80px);background:var(--card);border:1px solid var(--accent2);color:var(--accent2);font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:2px;padding:10px 20px;transition:transform 0.3s;z-index:100;}
  .toast.show{transform:translateX(-50%) translateY(0);}
  ::-webkit-scrollbar{width:4px;}
  ::-webkit-scrollbar-track{background:var(--bg);}
  ::-webkit-scrollbar-thumb{background:var(--border);}
</style>
</head>
<body>
<div class="container">

  <div class="header">
    <div class="header-badge">AI-POWERED MARKET INTELLIGENCE</div>
    <h1>APEX <span>SCANNER</span></h1>
    <div class="header-sub">CLAUDE AI + GEMINI AI ‚Äî CHOOSE YOUR ENGINE</div>
  </div>

  <div id="errorBox" style="display:none;background:rgba(255,51,102,0.1);border:1px solid var(--danger);border-radius:2px;padding:14px;margin-bottom:14px;font-family:'Share Tech Mono',monospace;font-size:11px;color:var(--danger);line-height:1.7;word-break:break-all;"></div>

  <div id="setupPanel">

    <!-- AI Engine -->
    <div class="section-label">00 ‚Äî SELECT AI ENGINE</div>
    <div class="card">
      <div class="engine-grid">
        <button class="engine-btn" id="engineClaude" onclick="selectEngine('claude')">
          <div class="engine-logo">ü§ñ</div>
          <div class="engine-name claude">CLAUDE</div>
          <div class="engine-desc">Anthropic's Claude Sonnet<br>Superior reasoning & analysis</div>
          <div class="engine-badge paid">$5 MIN CREDIT</div>
        </button>
        <button class="engine-btn active-gemini" id="engineGemini" onclick="selectEngine('gemini')">
          <div class="engine-logo">‚ú®</div>
          <div class="engine-name gemini">GEMINI</div>
          <div class="engine-desc">Gemini Flash via OpenRouter<br>Free tier, works everywhere</div>
          <div class="engine-badge free">FREE TIER AVAILABLE</div>
        </button>
      </div>
    </div>

    <!-- API Keys -->
    <div class="section-label">01 ‚Äî API KEY</div>
    <div class="card">
      <!-- Claude Key -->
      <div class="api-field" id="claudeField">
        <div class="api-label">CLAUDE API KEY</div>
        <input type="password" class="api-input" id="claudeKey"
               placeholder="sk-or-v1-..."
               oninput="saveKey('claude', this.value)" />
        <div class="api-actions">
          <button class="api-clear-btn" onclick="clearKey('claude')">‚úï CLEAR KEY</button>
          <a href="https://console.anthropic.com" target="_blank"
             style="font-family:'Share Tech Mono',monospace;font-size:9px;color:var(--accent);padding:5px 10px;border:1px solid rgba(0,212,255,0.3);text-decoration:none;">
            GET KEY ‚Üí
          </a>
        </div>
        <div class="api-note">One key works for ALL models. Get free key at <a href="https://openrouter.ai/keys" target="_blank">openrouter.ai/keys</a></div>
      </div>

      <!-- Gemini Key -->
      <div class="api-field visible" id="geminiField">
        <div class="api-label">GEMINI API KEY</div>
        <input type="password" class="api-input" id="geminiKey"
               placeholder="sk-or-v1-..."
               oninput="saveKey('gemini', this.value)" />
        <div class="api-actions">
          <button class="api-clear-btn" onclick="clearKey('gemini')">‚úï CLEAR KEY</button>
          <a href="https://aistudio.google.com/app/apikey" target="_blank"
             style="font-family:'Share Tech Mono',monospace;font-size:9px;color:var(--accent);padding:5px 10px;border:1px solid rgba(0,212,255,0.3);text-decoration:none;">
            GET FREE KEY ‚Üí
          </a>
        </div>
        <div class="api-note">Use the same OpenRouter key for both engines! Get it at <a href="https://openrouter.ai/keys" target="_blank">openrouter.ai/keys</a></div>
      </div>
    </div>

    <!-- Markets -->
    <div class="section-label">02 ‚Äî SELECT MARKETS</div>
    <div class="card">
      <div class="market-grid">
        <button class="market-btn active" data-market="crypto_top500" onclick="toggleMarket(this)">
          <span class="icon">‚Çø</span><div class="name">CRYPTO TOP 500</div><div class="desc">By market cap</div>
        </button>
        <button class="market-btn" data-market="crypto_top1000" onclick="toggleMarket(this)">
          <span class="icon">ü™ô</span><div class="name">CRYPTO TOP 1000</div><div class="desc">By market cap</div>
        </button>
        <button class="market-btn" data-market="sp500" onclick="toggleMarket(this)">
          <span class="icon">üìà</span><div class="name">S&amp;P 500</div><div class="desc">US large cap</div>
        </button>
        <button class="market-btn" data-market="nasdaq100" onclick="toggleMarket(this)">
          <span class="icon">üíª</span><div class="name">NASDAQ 100</div><div class="desc">Tech index</div>
        </button>
        <button class="market-btn" data-market="russell2000" onclick="toggleMarket(this)">
          <span class="icon">üè≠</span><div class="name">RUSSELL 2000</div><div class="desc">Small cap</div>
        </button>
        <button class="market-btn" data-market="defi" onclick="toggleMarket(this)">
          <span class="icon">‚õì</span><div class="name">DEFI TOKENS</div><div class="desc">Top DeFi</div>
        </button>
      </div>
    </div>

    <!-- Indicators -->
    <div class="section-label">03 ‚Äî INDICATORS</div>
    <div class="card">
      <div class="ind-grid">
        <button class="ind-btn active" data-ind="WaveTrend" onclick="toggleInd(this)">
          <div class="ind-name">WAVETREND</div><div class="ind-desc">WT1 cross WT2 oversold</div><div class="ind-check">‚úì</div>
        </button>
        <button class="ind-btn active" data-ind="RSI Divergence" onclick="toggleInd(this)">
          <div class="ind-name">RSI + DIVERGENCE</div><div class="ind-desc">Oversold + bullish div</div><div class="ind-check">‚úì</div>
        </button>
        <button class="ind-btn" data-ind="MACD Crossover" onclick="toggleInd(this)">
          <div class="ind-name">MACD</div><div class="ind-desc">Bullish crossover</div><div class="ind-check"></div>
        </button>
        <button class="ind-btn active" data-ind="Bollinger Band Lower Touch" onclick="toggleInd(this)">
          <div class="ind-name">BOLLINGER BANDS</div><div class="ind-desc">Price at lower band</div><div class="ind-check">‚úì</div>
        </button>
        <button class="ind-btn" data-ind="Stochastic RSI" onclick="toggleInd(this)">
          <div class="ind-name">STOCH RSI</div><div class="ind-desc">K cross D in oversold</div><div class="ind-check"></div>
        </button>
        <button class="ind-btn" data-ind="200 EMA proximity" onclick="toggleInd(this)">
          <div class="ind-name">200 EMA</div><div class="ind-desc">Price near 200 EMA</div><div class="ind-check"></div>
        </button>
        <button class="ind-btn active" data-ind="Volume Spike" onclick="toggleInd(this)">
          <div class="ind-name">VOLUME SPIKE</div><div class="ind-desc">1.5x average surge</div><div class="ind-check">‚úì</div>
        </button>
        <button class="ind-btn" data-ind="VWAP" onclick="toggleInd(this)">
          <div class="ind-name">VWAP</div><div class="ind-desc">Price below VWAP</div><div class="ind-check"></div>
        </button>
        <button class="ind-btn" data-ind="ATR Expansion" onclick="toggleInd(this)">
          <div class="ind-name">ATR</div><div class="ind-desc">Volatility expansion</div><div class="ind-check"></div>
        </button>
        <button class="ind-btn" data-ind="OBV Rising" onclick="toggleInd(this)">
          <div class="ind-name">OBV</div><div class="ind-desc">Accumulation signal</div><div class="ind-check"></div>
        </button>
        <button class="ind-btn active" data-ind="Liquidation Zone" onclick="toggleInd(this)">
          <div class="ind-name">LIQUIDATION MAP</div><div class="ind-desc">Price near long/short liq zone</div><div class="ind-check">‚úì</div>
        </button>
      </div>
    </div>

    <!-- Thresholds -->
    <div class="section-label">04 ‚Äî THRESHOLDS</div>
    <div class="card">
      <div class="slider-grid">
        <div class="slider-item">
          <label>WT OVERSOLD <span id="wtVal">-53</span></label>
          <input type="range" min="-90" max="-20" value="-53" step="1" oninput="document.getElementById('wtVal').textContent=this.value">
        </div>
        <div class="slider-item">
          <label>RSI OVERSOLD <span id="rsiVal">35</span></label>
          <input type="range" min="10" max="50" value="35" step="1" oninput="document.getElementById('rsiVal').textContent=this.value">
        </div>
        <div class="slider-item">
          <label>VOLUME MULTIPLIER <span id="volVal">1.5x</span></label>
          <input type="range" min="10" max="50" value="15" step="1" oninput="document.getElementById('volVal').textContent=(this.value/10).toFixed(1)+'x'">
        </div>
        <div class="slider-item">
          <label>MIN CONDITIONS <span id="minVal">2</span></label>
          <input type="range" min="1" max="5" value="2" step="1" oninput="document.getElementById('minVal').textContent=this.value" id="minT">
        </div>
      </div>
    </div>

    <!-- Telegram Settings -->
    <div class="section-label">05 ‚Äî TELEGRAM ALERTS (OPTIONAL)</div>
    <div class="card">
      <div class="slider-grid">
        <div>
          <div class="api-label">BOT TOKEN</div>
          <input type="password" class="api-input" id="tgToken" placeholder="123456:ABC-..." 
                 oninput="saveKey('tgToken', this.value)" style="margin-bottom:8px;" />
        </div>
        <div>
          <div class="api-label">CHAT ID</div>
          <input type="text" class="api-input" id="tgChatId" placeholder="-1001234567890"
                 oninput="saveKey('tgChatId', this.value)" style="margin-bottom:8px;" />
        </div>
      </div>
      <div class="api-note">Leave blank to skip Telegram. Alerts sent after scan completes.</div>
      <button onclick="testTelegram()" style="margin-top:10px;background:transparent;border:1px solid var(--warn);color:var(--warn);font-family:Share Tech Mono,monospace;font-size:10px;padding:8px 16px;cursor:pointer;letter-spacing:2px;width:100%;">
        &#9993; TEST TELEGRAM CONNECTION
      </button>
      <div id="tgTestResult" style="display:none;margin-top:8px;font-family:Share Tech Mono,monospace;font-size:10px;padding:8px;border-radius:2px;line-height:1.6;"></div>
    </div>

    <button class="scan-btn" id="scanBtn" onclick="runScan()">‚ö° ANALYZE WITH AI</button>
  </div>

  <!-- Loading -->
  <div class="loading" id="loading">
    <div id="engineLabel">AI IS ANALYZING MARKETS...</div>
    <div class="loading-bar"></div>
    <div id="loadingStatus" style="font-size:10px;color:var(--muted);margin-top:8px;">Initializing...</div>
  </div>

  <!-- Results -->
  <div class="results-section" id="resultsSection">
    <div class="results-header">
      <div class="section-label" style="margin:0;flex:1">SCAN RESULTS</div>
      <button class="new-scan-btn" onclick="newScan()">‚Ü∫ NEW SCAN</button>
    </div>
    <div class="results-stats">
      <div class="stat-box"><div class="stat-val" id="statTotal">0</div><div class="stat-label">TOTAL</div></div>
      <div class="stat-box"><div class="stat-val" id="statStrong" style="color:var(--accent2)">0</div><div class="stat-label">STRONG</div></div>
      <div class="stat-box"><div class="stat-val" id="statMod" style="color:var(--warn)">0</div><div class="stat-label">MODERATE</div></div>
      <div class="stat-box"><div class="stat-val" id="statEngine" style="font-size:14px">‚Äî</div><div class="stat-label">AI ENGINE</div></div>
    </div>
    <div class="ai-summary" id="aiSummary">
      <div class="ai-summary-title">‚ö° AI MARKET ANALYSIS</div>
      <div id="aiSummaryText"></div>
    </div>
    <div class="filter-bar">
      <button class="filter-btn active" onclick="filterAlerts('all',this)">ALL</button>
      <button class="filter-btn" onclick="filterAlerts('strong',this)">üî• STRONG</button>
      <button class="filter-btn" onclick="filterAlerts('moderate',this)">‚ö° MODERATE</button>
      <button class="filter-btn" onclick="filterAlerts('crypto',this)">‚Çø CRYPTO</button>
      <button class="filter-btn" onclick="filterAlerts('stocks',this)">üìà STOCKS</button>
    </div>
    <div id="alertsContainer"></div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
  let selectedEngine = 'gemini';
  let selectedMarkets = ['crypto_top500'];
  let selectedInds = ['WaveTrend','RSI Divergence','Bollinger Band Lower Touch','Volume Spike','Liquidation Zone'];
  let allAlerts = [];

  const MARKET_TICKERS = {
    crypto_top500:{label:'Crypto Top 500',type:'crypto',tickers:['BTC','ETH','BNB','XRP','SOL','ADA','DOGE','TRX','DOT','MATIC','LTC','SHIB','AVAX','LINK','ATOM','UNI','XMR','ETC','XLM','BCH','ALGO','VET','FIL','ICP','HBAR','APT','ARB','NEAR','QNT','GRT','AAVE','SAND','MANA','AXS','THETA','EOS','NEO','MKR','SNX','COMP','CRV','YFI','SUSHI','ENJ','CHZ','ZIL','BAT','HOT','ONT','DASH','ZEC','IOTA','XTZ','EGLD','FTM','ONE','KAVA','CELO','FLOW','ROSE','SKL','ANKR','OGN','SLP','ALICE','REEF','TLM','DENT','WIN','SC','DGB','RVN','SYS','ARDR','NXT','STEEM','LSK','PIVX','QTUM','WAN','ICX','IOST','ARK','NULS','WTC','WAVES','RUNE','LDO','FXS','CVX','GMX','DYDX','GNS','JOE','PERP','STX','IMX','OP','INJ','SUI','SEI','TIA','PYTH','JUP','WIF','BONK','PEPE','FLOKI','TURBO','ORDI','SATS','RATS','MEME','BOME','SLERF','WEN','MYRO','POPCAT','MEW','BRETT','MOG','PONKE','RETARDIO','GIGA','PNUT','ACT','GOAT','MOODENG','NEIRO','EIGEN','DRIFT','CLOUD','IO','ZK','STRK','ALT','DYM','PIXEL','PORTAL','MANTA','AEVO','SAGA','OMNI','REZ','BB','NOT','DOGS','CATI','HMSTR','MAJOR','BLUM','BCUT','PAWS','GRAM','X','AGENT','GAME','TAO','RENDER','FET','AGIX','OCEAN','NMR','RLC','GRT','LPT','API3','BAND','TRB','LINK','UMA','ARKM','ONDO','PYUSD','FDUSD','TUSD','USDP','GUSD','USDD','FRAX','LUSD','CRVUSD','GHO','ALUSD','SUSD','DOLA','MIM','MAI','USDR','CUSD','BUSD','USDJ','ZUSD','USDX','HUSD','USDK','USDQ','USDT','USDC','DAI','USDN','TRIBE','FEI','FLOAT','BEAN','USDAP','USDL','USDM','USDV','USD0','USDY','USDZ','USDEX','USDW','USDH','USDF','USDG','USDB','USDA','USDE','SUSDX','AVT','TRAC','NKN','CTXC','LAMB','MTN','OGO','BLTV','BTCST','CHESS','TORN','CFX','EFI','MULTI','SPOOL','DODO','BURGER','XVS','ALPACA','BIFI','AUTO','CAKE','BELT','BUNNY','EPS','HARD','BOR','UNFI','SFP','AUCTION','BADGER','DIGG','FARM','PICKLE','COVER','ROOK','KEEP','NU','T','ALCX','TOKE','IDLE','BOND','POLS','API3','BETA','OOKI','MBL','AKRO','DF','IRIS','YFII','SRM','FIDA','KIN','MAPS','OXY','MEDIA','COPE','RAY','MER','STEP','SNY','PORT','SAIL','SLRS','MNGO','ABR','LIQ','TULIP','SUNNY','LARIX','KURO','SBR','ORCA','SABER','GOFX','SERUM']},
    crypto_top1000:{label:'Crypto Top 1000',type:'crypto',tickers:['BTC','ETH','BNB','XRP','SOL','ADA','DOGE','TRX','DOT','MATIC','LTC','SHIB','AVAX','LINK','ATOM','UNI','XMR','ETC','XLM','BCH','ALGO','VET','FIL','ICP','HBAR','APT','ARB','NEAR','QNT','GRT','AAVE','SAND','MANA','AXS','THETA','EOS','NEO','MKR','SNX','COMP','CRV','YFI','SUSHI','ENJ','CHZ','ZIL','BAT','HOT','ONT','DASH','ZEC','IOTA','XTZ','EGLD','FTM','ONE','KAVA','CELO','FLOW','ROSE','SKL','ANKR','OGN','SLP','ALICE','REEF','TLM','DENT','WIN','SC','DGB','RVN','SYS','ARDR','NXT','STEEM','LSK','PIVX','QTUM','WAN','ICX','IOST','ARK','NULS','WTC','WAVES','RUNE','LDO','FXS','CVX','GMX','DYDX','GNS','JOE','PERP','STX','IMX','OP','INJ','SUI','SEI','TIA','PYTH','JUP','WIF','BONK','PEPE','FLOKI','TURBO','ORDI','MEME','BOME','POPCAT','MEW','BRETT','MOG','PONKE','GIGA','PNUT','ACT','GOAT','MOODENG','NEIRO','EIGEN','DRIFT','CLOUD','IO','ZK','STRK','ALT','DYM','PIXEL','PORTAL','MANTA','AEVO','SAGA','OMNI','REZ','BB','NOT','DOGS','CATI','HMSTR','MAJOR','TAO','RENDER','FET','AGIX','OCEAN','NMR','RLC','LPT','API3','BAND','TRB','UMA','ARKM','ONDO','CFX','DODO','XVS','ALPACA','BIFI','CAKE','BELT','BUNNY','EPS','HARD','UNFI','SFP','AUCTION','BADGER','DIGG','FARM','PICKLE','COVER','KEEP','NU','T','ALCX','TOKE','IDLE','BOND','POLS','BETA','OOKI','MBL','AKRO','DF','IRIS','YFII','RAY','SNY','MNGO','ORCA','SABER','ACH','ADX','AERGO','AGLD','AMP','ARPA','ATM','AVA','AVAX','AXS','BADGER','BAKE','BALANCER','BAND','BAR','BCH','BEAM','BETA','BICO','BLUR','BLZ','BNT','BOBA','BOND','BSW','BTG','BTS','BTT','C98','CELR','CFX','CHR','CITY','CLV','COCOS','COMBO','CORE','COT','CTK','CTSI','CYBER','DEGO','DENT','DIA','DOCK','DUSK','DYDX','EDU','ELF','EPX','ERN','ETCX','FARM','FOR','FORTH','FTT','FUN','GAL','GALA','GAS','GBP','GHST','GLM','GLMR','GMT','GNO','GNS','HARD','HFT','HIGH','HOOK','ID','IDEX','ILV','IOST','IQ','JASMY','JOE','JST','KAVA','KDA','KEY','KLAY','KMD','KP3R','KSM','LAZIO','LEND','LEVER','LINA','LISTA','LOKA','LOOM','LQTY','LUNC','MAGIC','MASK','MC','MDAO','MDT','MINA','MIR','MLN','MOVR','MTL','MULTI','MVL','MXC','NEXO','NFP','NMR','NTRN','OAX','OG','OGN','OMG','ONE','ONT','OOKI','ORC','OXT','PAXG','PEOPLE','PERP','PHA','PIVX','PLA','PLN','POLY','POND','PORTO','PROM','PROS','PSG','PYR','QI','QKC','QNT','QUICK','RAD','RDNT','REEF','REI','REN','REP','REQ','REVOLT','RIF','RNDR','RONIN','RPL','RUNE','SANTOS','SC','SCRT','SFP','SKL','SLPX','SNT','SOL','SPARTA','SPELL','STEEM','STMX','STORJ','STX','SUI','SUPER','SUSHI','SXP','SYS','TOMO','TORN','TRB','TRIBE','TROY','TRU','TWT','UFT','UNIBOT','USDT','UTK','VELO','VERSE','VIDT','VITE','VOXEL','VTHO','WAN','WING','WNCG','WOO','XEC','XEM','XNO','XVG','XVS','YGG','ZEC','ZEN','ZIL','ZRX','DOGE','SHIB','FLOKI','LUNC','ELON','BABY','SAMO','HOGE','PIG','LEASH','KISHU','SAITAMA','AKITA','DOGELON','VOLT','PITBULL','JACY','FLOKINOMICS','FLOKI','SAFEMOON','ELONGATE','HOKK','PIG','SHINJA','MOONSHOT','TFLOKI','FLOKIM']},
    sp500:{label:'S&P 500',type:'stock',tickers:['AAPL','MSFT','AMZN','NVDA','GOOGL','META','TSLA','BRK-B','UNH','LLY','JPM','V','XOM','MA','PG','JNJ','HD','AVGO','MRK','CVX','PEP','ABBV','COST','KO','WMT','ADBE','CRM','BAC','MCD','PFE','TMO','CSCO','ABT','ACN','NKE','DHR','LIN','CMCSA','TXN','VZ','PM','NEE','RTX','HON','AMGN','IBM','UNP','INTC','QCOM','INTU','SBUX','GE','LOW','AMD','CAT','DE','SPGI','MS','GS','BLK']},
    nasdaq100:{label:'Nasdaq 100',type:'stock',tickers:['AAPL','MSFT','AMZN','NVDA','GOOGL','GOOG','META','TSLA','AVGO','ADBE','CSCO','CMCSA','INTC','AMD','INTU','QCOM','HON','AMAT','SBUX','MDLZ','GILD','REGN','VRTX','ISRG','KLAC','LRCX','SNPS','CDNS','MRVL','PANW','CRWD','NFLX','PYPL','ADP','MELI','ASML','COST','PDD','KDP','ORLY','PCAR','CTAS','FTNT','FAST','CPRT','MNST','DDOG','ROST','PAYX','ODFL']},
    russell2000:{label:'Russell 2000',type:'stock',tickers:['SMCI','SAIA','GTLS','CHRD','RMBS','HALO','MGNI','CSWI','UFPI','PLXS','ITRI','ESAB','AAON','SPSC','ACLS','SFBS','CABO','ALRM','KTOS','AEIS','CPRX','MSGS','IRTC','MGPI','HTLF','PTCT','FORM','NSIT','TGTX','IDEX','AGIO','CARG','PRGS','DFIN','NEOG','HLIO','DNOW','BOOT','REPX','ARCH','AORT','INVA','DXPE','LQDT','MYRG','CNXN','PAHC','RELY','HTLD','PZZA']},
    defi:{label:'DeFi Tokens',type:'crypto',tickers:['UNI','AAVE','MKR','COMP','CRV','SNX','BAL','YFI','SUSHI','1INCH','CAKE','RUNE','LDO','FXS','CVX','GMX','DYDX','GNS','JOE','PERP']}
  };

  // ‚îÄ‚îÄ Engine selection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  function selectEngine(engine) {
    selectedEngine = engine;
    document.getElementById('engineClaude').className = 'engine-btn' + (engine==='claude' ? ' active-claude' : '');
    document.getElementById('engineGemini').className = 'engine-btn' + (engine==='gemini' ? ' active-gemini' : '');
    document.getElementById('claudeField').className = 'api-field' + (engine==='claude' ? ' visible' : '');
    document.getElementById('geminiField').className = 'api-field' + (engine==='gemini' ? ' visible' : '');
  }

  // ‚îÄ‚îÄ Key storage ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  function saveKey(engine, val) {
    try { localStorage.setItem('apex_key_'+engine, val); } catch(e) {}
  }

  function clearKey(engine) {
    try {
      localStorage.removeItem('apex_key_'+engine);
      document.getElementById(engine+'Key').value = '';
      showToast('KEY CLEARED');
    } catch(e) {}
  }

  function loadKeys() {
    try {
      const ck = localStorage.getItem('apex_key_claude');
      const gk = localStorage.getItem('apex_key_gemini');
      const tt = localStorage.getItem('apex_key_tgToken');
      const tc = localStorage.getItem('apex_key_tgChatId');
      if (ck) document.getElementById('claudeKey').value = ck;
      if (gk) document.getElementById('geminiKey').value = gk;
      if (tt) document.getElementById('tgToken').value = tt;
      if (tc) document.getElementById('tgChatId').value = tc;
    } catch(e) {}
  }

  window.addEventListener('load', loadKeys);

  // ‚îÄ‚îÄ Market / indicator toggles ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  function toggleMarket(btn) {
    try {
      const m = btn.dataset.market;
      if (!m) return;
      if (selectedMarkets.includes(m)) {
        selectedMarkets = selectedMarkets.filter(function(x) { return x !== m; });
        btn.classList.remove('active');
      } else {
        selectedMarkets.push(m);
        btn.classList.add('active');
      }
    } catch(e) { console.error('toggleMarket error:', e); }
  }

  function toggleInd(btn) {
    try {
      const ind = btn.dataset.ind;
      if (!ind) return;
      const check = btn.querySelector('.ind-check');
      if (selectedInds.includes(ind)) {
        selectedInds = selectedInds.filter(function(x) { return x !== ind; });
        btn.classList.remove('active');
        if (check) check.textContent = '';
      } else {
        selectedInds.push(ind);
        btn.classList.add('active');
        if (check) check.textContent = '‚úì';
      }
    } catch(e) { console.error('toggleInd error:', e); }
  }

  function showToast(msg) {
    const t=document.getElementById('toast'); t.textContent=msg; t.classList.add('show');
    setTimeout(()=>t.classList.remove('show'),8000);
  }

  function showError(msg) {
    console.error('APEX ERROR:', msg);
    const box = document.getElementById('errorBox');
    if (box) { box.textContent = msg; box.style.display = 'block'; }
    const loading = document.getElementById('loading');
    if (loading) loading.classList.remove('visible');
    const panel = document.getElementById('setupPanel');
    if (panel) panel.style.display = 'block';
    showToast(msg.substring(0, 60));
  }

  function newScan() {
    document.getElementById('resultsSection').classList.remove('visible');
    document.getElementById('setupPanel').style.display='block';
    allAlerts=[];
  }

  // ‚îÄ‚îÄ API calls via OpenRouter (no backend needed) ‚îÄ‚îÄ‚îÄ‚îÄ
  async function callAI(prompt) {
    const keyId = selectedEngine === 'claude' ? 'claudeKey' : 'geminiKey';
    const apiKey = document.getElementById(keyId).value.trim();
    if (!apiKey) throw new Error('Enter your OpenRouter API key first ‚Äî get one free at openrouter.ai/keys');

    const model = selectedEngine === 'claude'
      ? 'anthropic/claude-haiku-4-5'
      : 'google/gemini-2.0-flash-001';

    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + apiKey,
        'HTTP-Referer': 'https://apex-scanner.app',
        'X-Title': 'APEX SCANNER'
      },
      body: JSON.stringify({
        model: model,
        max_tokens: 1024,
        messages: [{ role: 'user', content: prompt }]
      })
    });

    const rawText = await response.text();
    let data;
    try {
      data = JSON.parse(rawText);
    } catch(e) {
      throw new Error('Invalid response: ' + rawText.substring(0, 200));
    }
    if (!response.ok || data.error) throw new Error(data.error?.message || JSON.stringify(data.error) || 'API error');
    return data.choices[0].message.content;
  }

  // ‚îÄ‚îÄ Render ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  function getSignalClass(s) {
    s=s.toLowerCase();
    if(s.includes('wt')||s.includes('wave')) return 'wt';
    if(s.includes('rsi')) return 'rsi';
    if(s.includes('vol')) return 'vol';
    if(s.includes('bb')||s.includes('bolling')) return 'bb';
    if(s.includes('macd')) return 'macd';
    return 'other';
  }

  function renderAlerts(alerts) {
    const c = document.getElementById('alertsContainer');
    c.innerHTML = '';
    if (alerts.length === 0) {
      c.innerHTML = '<div style="text-align:center;padding:40px;font-family:Share Tech Mono,monospace;font-size:12px;color:var(--muted);">NO ALERTS FOR CURRENT FILTER</div>';
      return;
    }
    alerts.forEach(function(a) {
      const isStrong = a.score >= 3;
      const card = document.createElement('div');
      card.className = 'alert-card ' + (isStrong ? 'strong' : 'moderate');
      card.dataset.type = a.type || '';
      card.dataset.strength = isStrong ? 'strong' : 'moderate';
      const signals = a.signals || [];

      // Build signals HTML
      let signalsHtml = '';
      signals.forEach(function(s) {
        signalsHtml += '<span class="signal-tag ' + getSignalClass(s) + '">' + s + '</span>';
      });

      // Build sentiment badge
      let sentimentHtml = '';
      if (a.sentiment) {
        let sentColor = 'color:#ffb800;border-color:rgba(255,184,0,0.4);background:rgba(255,184,0,0.06)';
        if (a.sentimentEmoji === 'green') sentColor = 'color:#00ff88;border-color:rgba(0,255,136,0.4);background:rgba(0,255,136,0.06)';
        if (a.sentimentEmoji === 'red') sentColor = 'color:#ff3366;border-color:rgba(255,51,102,0.4);background:rgba(255,51,102,0.06)';
        sentimentHtml = '<div style="margin-top:8px;font-family:Share Tech Mono,monospace;font-size:10px;padding:4px 10px;display:inline-block;border-radius:2px;border:1px solid;' + sentColor + '">REDDIT: ' + a.sentiment + '</div>';
      }

      // Build values
      let valuesHtml = '';
      if (a.wt1 !== undefined) valuesHtml += '<div class="alert-val">WT1 <span>' + a.wt1 + '</span></div>';
      if (a.rsi !== undefined) valuesHtml += '<div class="alert-val">RSI <span>' + a.rsi + '</span></div>';
      if (a.timeframe) valuesHtml += '<div class="alert-val">TF <span>' + a.timeframe + '</span></div>';

      card.innerHTML =
        '<div class="alert-top">' +
          '<div>' +
            '<div class="alert-symbol">' + (a.symbol || '') + '</div>' +
            '<div class="alert-market">' + (a.market || '') + ' &bull; ' + ((a.type || '').toUpperCase()) + '</div>' +
          '</div>' +
          '<div style="text-align:right">' +
            '<div class="alert-score ' + (isStrong ? '' : 'moderate') + '">' + a.score + '/' + selectedInds.length + '</div>' +
            '<div style="font-family:Share Tech Mono,monospace;font-size:9px;color:var(--muted);margin-top:2px;">' + (isStrong ? '&#128293; STRONG' : '&#9889; MODERATE') + '</div>' +
          '</div>' +
        '</div>' +
        '<div class="alert-signals">' + signalsHtml + '</div>' +
        '<div class="alert-analysis">' + (a.analysis || '') + '</div>' +
        sentimentHtml +
        '<div class="alert-values">' + valuesHtml + '</div>';

      c.appendChild(card);
    });
  }


  function filterAlerts(type,btn) {
    document.querySelectorAll('.filter-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    let f=allAlerts;
    if(type==='strong') f=allAlerts.filter(a=>a.score>=3);
    else if(type==='moderate') f=allAlerts.filter(a=>a.score===2);
    else if(type==='crypto') f=allAlerts.filter(a=>a.type==='crypto');
    else if(type==='stocks') f=allAlerts.filter(a=>a.type==='stock');
    renderAlerts(f);
  }

  // ‚îÄ‚îÄ Binance liquidation zone fetch ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  async function fetchLiquidationData(symbols) {
    const results = {};
    const binanceSymbols = symbols
      .filter(t => t.type === 'crypto')
      .map(t => ({ symbol: t.symbol, pair: t.symbol + 'USDT' }));

    await Promise.all(binanceSymbols.map(async ({ symbol, pair }) => {
      try {
        const [oiRes, frRes, priceRes] = await Promise.all([
          fetch(`https://fapi.binance.com/fapi/v1/openInterest?symbol=${pair}`),
          fetch(`https://fapi.binance.com/fapi/v1/fundingRate?symbol=${pair}&limit=1`),
          fetch(`https://fapi.binance.com/fapi/v1/ticker/price?symbol=${pair}`)
        ]);

        if (!oiRes.ok || !frRes.ok || !priceRes.ok) return;

        const oi = await oiRes.json();
        const fr = await frRes.json();
        const price = await priceRes.json();

        const currentPrice = parseFloat(price.price);
        const fundingRate = parseFloat(fr[0]?.fundingRate || 0);
        const openInterest = parseFloat(oi.openInterest);

        // Estimate liquidation zones:
        // Positive funding = longs dominant = long liq below, short liq above
        // Negative funding = shorts dominant = short liq below, long liq above
        // Estimate leverage from funding rate:
        // High positive funding = longs very crowded = higher leverage = tighter liq zone
        // High negative funding = shorts very crowded = higher leverage = tighter liq zone
        const absFunding = Math.abs(fundingRate);
        let estimatedLeverage;
        if (absFunding > 0.003) estimatedLeverage = 25;       // extremely crowded = 25x
        else if (absFunding > 0.001) estimatedLeverage = 15;  // very crowded = 15x
        else if (absFunding > 0.0005) estimatedLeverage = 10; // moderately crowded = 10x
        else if (absFunding > 0.0002) estimatedLeverage = 7;  // slightly crowded = 7x
        else estimatedLeverage = 5;                            // neutral = 5x

        // Longs get liquidated below, shorts above
        // Positive funding = longs dominant = long liq is closer (tighter)
        // Negative funding = shorts dominant = short liq is closer (tighter)
        const longLiqDistance = fundingRate >= 0
          ? (1 / estimatedLeverage)         // longs crowded = closer long liq
          : (1 / (estimatedLeverage * 0.6)); // shorts crowded = farther long liq

        const shortLiqDistance = fundingRate < 0
          ? (1 / estimatedLeverage)          // shorts crowded = closer short liq
          : (1 / (estimatedLeverage * 0.6)); // longs crowded = farther short liq

        const longLiqZone = currentPrice * (1 - longLiqDistance);
        const shortLiqZone = currentPrice * (1 + shortLiqDistance);

        // Calculate exact distance % to each liquidation zone
        const distToLongLiq = ((currentPrice - longLiqZone) / currentPrice * 100).toFixed(2);
        const distToShortLiq = ((shortLiqZone - currentPrice) / currentPrice * 100).toFixed(2);

        // Alert if price is within 12% of either liquidation zone
        const nearLongLiq = parseFloat(distToLongLiq) <= 12;
        const nearShortLiq = parseFloat(distToShortLiq) <= 12;

        results[symbol] = {
          price: currentPrice,
          fundingRate,
          openInterest,
          longLiqZone: longLiqZone.toFixed(4),
          shortLiqZone: shortLiqZone.toFixed(4),
          distToLongLiq,
          distToShortLiq,
          nearLongLiq,
          nearShortLiq,
          fundingBias: fundingRate > 0.0005 ? 'LONGS_CROWDED' : fundingRate < -0.0005 ? 'SHORTS_CROWDED' : 'NEUTRAL',
          alert: nearLongLiq || nearShortLiq,
          alertType: nearLongLiq ? 'NEAR_LONG_LIQ' : nearShortLiq ? 'NEAR_SHORT_LIQ' : null
        };
      } catch(e) {
        // Symbol not on Binance futures, skip
      }
    }));
    return results;
  }

  // ‚îÄ‚îÄ Telegram sender ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  async function sendTelegram(alerts, liqData) {
    const token = document.getElementById('tgToken').value.trim();
    const chatId = document.getElementById('tgChatId').value.trim();
    if (!token || !chatId) return;

    const strong = alerts.filter(a => a.score >= 3);
    const liqAlerts = Object.entries(liqData).filter(([,d]) => d && d.alert);

    let lines = [];
    lines.push('APEX SCANNER RESULTS');
    lines.push(new Date().toDateString());
    lines.push('');

    if (strong.length > 0) {
      lines.push('STRONG SIGNALS (' + strong.length + ')');
      strong.forEach(a => {
        lines.push('');
        lines.push(a.symbol + ' - Score: ' + a.score + '/' + selectedInds.length);
        lines.push('Signals: ' + (a.signals||[]).join(', '));
        lines.push(a.analysis || '');
        if (a.sentiment) lines.push('Sentiment: ' + a.sentiment);
      });
    } else {
      lines.push('No strong signals found.');
    }

    if (liqAlerts.length > 0) {
      lines.push('');
      lines.push('LIQUIDATION ZONE ALERTS (' + liqAlerts.length + ')');
      liqAlerts.forEach(function(entry) {
        var sym = entry[0], d = entry[1];
        var type = d.alertType === 'NEAR_LONG_LIQ' ? 'Near LONG liq' : 'Near SHORT liq';
        lines.push('');
        var dist = d.alertType === 'NEAR_LONG_LIQ' ? d.distToLongLiq : d.distToShortLiq;
        lines.push(sym + ' - ' + type + ' (' + dist + '% away)');
        lines.push('Price: $' + d.price + ' | Liq Zone: $' + (d.alertType === 'NEAR_LONG_LIQ' ? d.longLiqZone : d.shortLiqZone));
        lines.push('Funding: ' + (d.fundingRate*100).toFixed(4) + '% | ' + d.fundingBias);
      });
    }

    const msg = lines.join('\n');

    // Split into 4000 char chunks
    const chunks = [];
    for (let i = 0; i < msg.length; i += 4000) {
      chunks.push(msg.slice(i, i + 4000));
    }

    for (const chunk of chunks) {
      try {
        const parsedChatId = isNaN(chatId) ? chatId : parseInt(chatId);
        const res = await fetch('https://api.telegram.org/bot' + token + '/sendMessage', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ chat_id: parsedChatId, text: chunk })
        });
        if (!res.ok) {
          const errText = await res.text();
          throw new Error('HTTP ' + res.status + ': ' + errText.substring(0, 100));
        }
        const data = await res.json();
        if (!data.ok) throw new Error(data.description || 'Telegram rejected message');
      } catch(e) {
        showError('Telegram error: ' + e.message);
        return;
      }
    }
  }

  // ‚îÄ‚îÄ Reddit sentiment fetch ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  async function fetchRedditSentiment(symbols) {
    const sentiment = {};
    const allSymbols = symbols.slice(0, 20); // limit to top 20 alerts

    await Promise.all(allSymbols.map(async ({ symbol, type }) => {
      try {
        const isCrypto = type === 'crypto';
        const query = isCrypto
          ? encodeURIComponent(symbol + ' crypto')
          : encodeURIComponent(symbol + ' stock');
        const url = 'https://www.reddit.com/search.json?q=' + query + '&sort=hot&limit=10&t=day';

        const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
        if (!res.ok) return;
        const data = await res.json();

        const posts = data.data?.children || [];
        if (posts.length === 0) { sentiment[symbol] = { score: 0, posts: 0, label: 'NO DATA' }; return; }

        let bullish = 0, bearish = 0, totalUpvotes = 0;
        posts.forEach(p => {
          const title = (p.data.title || '').toLowerCase();
          const ups = p.data.ups || 0;
          totalUpvotes += ups;
          const bullWords = ['moon', 'pump', 'bullish', 'buy', 'long', 'breakout', 'surge', 'rally', 'up', 'gain', 'beat', 'earnings beat', 'upgrade', 'outperform', 'oversold', 'accumulate', 'undervalued', 'strong'];
          const bearWords = ['dump', 'bearish', 'sell', 'short', 'crash', 'drop', 'down', 'fall', 'loss', 'rug', 'miss', 'earnings miss', 'downgrade', 'overbought', 'overvalued', 'weak', 'avoid', 'layoffs'];
          bullWords.forEach(w => { if (title.includes(w)) bullish++; });
          bearWords.forEach(w => { if (title.includes(w)) bearish++; });
        });

        const sentScore = bullish - bearish;
        const label = sentScore > 1 ? 'BULLISH' : sentScore < -1 ? 'BEARISH' : 'NEUTRAL';
        sentiment[symbol] = {
          score: sentScore,
          posts: posts.length,
          upvotes: totalUpvotes,
          label,
          emoji: sentScore > 1 ? 'green' : sentScore < -1 ? 'red' : 'yellow'
        };
      } catch(e) {
        sentiment[symbol] = { score: 0, posts: 0, label: 'ERROR' };
      }
    }));
    return sentiment;
  }

  // ‚îÄ‚îÄ Test Telegram ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  async function testTelegram() {
    const token = document.getElementById('tgToken').value.trim();
    const chatId = document.getElementById('tgChatId').value.trim();
    const result = document.getElementById('tgTestResult');
    result.style.display = 'block';

    if (!token) { result.style.color='#ff3366'; result.textContent='ERROR: Enter your bot token first'; return; }
    if (!chatId) { result.style.color='#ff3366'; result.textContent='ERROR: Enter your chat ID first'; return; }

    result.style.color='#ffb800';
    result.textContent='Testing connection...';

    try {
      // First verify the bot token
      const botRes = await fetch('https://api.telegram.org/bot' + token + '/getMe');
      const botData = await botRes.json();
      if (!botData.ok) {
        result.style.color='#ff3366';
        result.textContent='ERROR: Invalid bot token. Get it from @BotFather on Telegram.';
        return;
      }

      const botName = botData.result.username;

      // Now send a test message
      const parsedChatId = isNaN(chatId) ? chatId : parseInt(chatId);
      const msgRes = await fetch('https://api.telegram.org/bot' + token + '/sendMessage', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ chat_id: parsedChatId, text: 'APEX SCANNER: Connection test successful! Your alerts are configured correctly.' })
      });
      const msgData = await msgRes.json();

      if (msgData.ok) {
        result.style.color='#00ff88';
        result.textContent='SUCCESS: Bot @' + botName + ' connected! Check your Telegram for the test message.';
      } else {
        result.style.color='#ff3366';
        result.textContent='ERROR: Bot token is valid but chat ID is wrong. Error: ' + msgData.description + '. Get your correct chat ID from @userinfobot on Telegram.';
      }
    } catch(e) {
      result.style.color='#ff3366';
      result.textContent='ERROR: ' + e.message + '. Make sure your internet connection is working.';
    }
  }

  // ‚îÄ‚îÄ Main scan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  async function runScan() {
    if(selectedMarkets.length===0){showToast('SELECT AT LEAST ONE MARKET');return;}
    if(selectedInds.length===0){showToast('SELECT AT LEAST ONE INDICATOR');return;}

    const wtT=document.getElementById('wtVal').textContent;
    const rsiT=document.getElementById('rsiVal').textContent;
    const volT=document.getElementById('volVal').textContent;
    const minT=document.getElementById('minT').value;
    const engineName=selectedEngine==='claude'?'CLAUDE':'GEMINI';

    document.getElementById('setupPanel').style.display='none';
    document.getElementById('loading').classList.add('visible');
    document.getElementById('resultsSection').classList.remove('visible');
    document.getElementById('engineLabel').textContent=`${engineName} IS ANALYZING MARKETS...`;
    allAlerts=[];

    try {
      let allTickers=[];
      selectedMarkets.forEach(m=>{
        if(MARKET_TICKERS[m]){
          MARKET_TICKERS[m].tickers.forEach(t=>{
            allTickers.push({symbol:t,market:MARKET_TICKERS[m].label,type:MARKET_TICKERS[m].type});
          });
        }
      });
      const seen=new Set();
      allTickers=allTickers.filter(t=>{if(seen.has(t.symbol))return false;seen.add(t.symbol);return true;});

      const marketsList=selectedMarkets.map(m=>MARKET_TICKERS[m]?.label).join(', ');

      // Split into batches of 50 to avoid prompt size limits
      // ‚îÄ‚îÄ Fetch real market data ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      async function fetchBinanceCandles(symbol) {
        try {
          const url = 'https://fapi.binance.com/fapi/v1/klines?symbol=' + symbol + 'USDT&interval=1w&limit=210';
          const res = await fetch(url);
          if (!res.ok) return null;
          return await res.json();
        } catch(e) { return null; }
      }

      async function fetchStockData(symbol) {
        // Try multiple proxies in order
        const proxies = [
          'https://query1.finance.yahoo.com/v8/finance/chart/' + symbol + '?interval=1wk&range=4y',
          'https://corsproxy.io/?' + encodeURIComponent('https://query1.finance.yahoo.com/v8/finance/chart/' + symbol + '?interval=1wk&range=4y'),
          'https://api.allorigins.win/raw?url=' + encodeURIComponent('https://query1.finance.yahoo.com/v8/finance/chart/' + symbol + '?interval=1wk&range=4y')
        ];

        for (const url of proxies) {
          try {
            const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
            if (!res.ok) continue;
            const data = await res.json();
            const q = data.chart && data.chart.result && data.chart.result[0];
            if (!q) continue;
            const closes = q.indicators.quote[0].close;
            const volumes = q.indicators.quote[0].volume;
            if (!closes || closes.length < 20) continue;
            return { closes: closes.filter(Boolean), volumes: volumes.filter(Boolean) };
          } catch(e) { continue; }
        }
        return null;
      }

      function calcRSI(closes, period) {
        if (closes.length < period + 1) return null;
        let gains = 0, losses = 0;
        for (let i = closes.length - period; i < closes.length; i++) {
          const diff = closes[i] - closes[i-1];
          if (diff > 0) gains += diff; else losses += Math.abs(diff);
        }
        const rs = gains / (losses || 0.0001);
        return parseFloat((100 - 100/(1+rs)).toFixed(2));
      }

      function calcEMA(closes, period) {
        if (closes.length < period) return null;
        const k = 2/(period+1);
        let ema = closes.slice(0, period).reduce((a,b)=>a+b,0) / period;
        for (let i = period; i < closes.length; i++) ema = closes[i]*k + ema*(1-k);
        return parseFloat(ema.toFixed(4));
      }

      function calcWaveTrend(closes, n1, n2) {
        if (closes.length < n2 + 4) return null;
        const hlc3 = closes; // weekly close approximation
        const esa = calcEMA(hlc3, n1);
        const d = hlc3.map((v, i) => Math.abs(v - (calcEMA(hlc3.slice(0, i+1), n1) || v)));
        const de = calcEMA(d, n1);
        const ci = de ? (closes[closes.length-1] - esa) / (0.015 * de) : 0;
        return parseFloat(ci.toFixed(2));
      }

      function calcVolumeSpike(volumes) {
        if (volumes.length < 20) return null;
        const avg = volumes.slice(-20, -1).reduce((a,b)=>a+b,0) / 19;
        const current = volumes[volumes.length-1];
        return parseFloat((current / avg).toFixed(2));
      }

      // Fetch real data for all tickers in parallel (batches of 10 to avoid rate limits)
      const DATA_BATCH = 10;
      const realDataMap = {};
      const cryptoTickers = allTickers.filter(t => t.type === 'crypto');
      const stockTickers = allTickers.filter(t => t.type === 'stock');

      document.getElementById('loadingStatus').textContent = 'Fetching real market data for ' + allTickers.length + ' assets...';

      // Fetch crypto data from Binance
      for (let i = 0; i < cryptoTickers.length; i += DATA_BATCH) {
        const batch = cryptoTickers.slice(i, i + DATA_BATCH);
        document.getElementById('loadingStatus').textContent = 'Fetching crypto data ' + (i+1) + '-' + Math.min(i+DATA_BATCH, cryptoTickers.length) + ' of ' + cryptoTickers.length + '...';
        await Promise.all(batch.map(async function(t) {
          const candles = await fetchBinanceCandles(t.symbol);
          if (!candles || candles.length < 20) return;
          const closes = candles.map(function(c) { return parseFloat(c[4]); });
          const volumes = candles.map(function(c) { return parseFloat(c[5]); });
          const rsi = calcRSI(closes, 14);
          const ema200 = calcEMA(closes, 200);
          const ema50 = calcEMA(closes, 50);
          const wt1 = calcWaveTrend(closes, 10, 21);
          const volSpike = calcVolumeSpike(volumes);
          const price = closes[closes.length-1];
          realDataMap[t.symbol] = {
            price, rsi, ema200, ema50, wt1, volSpike,
            priceVsEma200: ema200 ? parseFloat(((price/ema200-1)*100).toFixed(2)) : null,
            priceVsEma50: ema50 ? parseFloat(((price/ema50-1)*100).toFixed(2)) : null,
            type: 'crypto'
          };
        }));
        if (i + DATA_BATCH < cryptoTickers.length) await new Promise(function(r) { setTimeout(r, 200); });
      }

      // Fetch stock data from Yahoo Finance
      let stockDataCount = 0;
      for (let i = 0; i < stockTickers.length; i += DATA_BATCH) {
        const batch = stockTickers.slice(i, i + DATA_BATCH);
        document.getElementById('loadingStatus').textContent = 'Fetching stock data ' + (i+1) + '-' + Math.min(i+DATA_BATCH, stockTickers.length) + ' of ' + stockTickers.length + ' (got data for ' + stockDataCount + ' so far)...';
        await Promise.all(batch.map(async function(t) {
          const data = await fetchStockData(t.symbol);
          if (!data) return;
          const { closes, volumes } = data;
          const rsi = calcRSI(closes, 14);
          const ema200 = calcEMA(closes, 200);
          const ema50 = calcEMA(closes, 50);
          const wt1 = calcWaveTrend(closes, 10, 21);
          const volSpike = calcVolumeSpike(volumes);
          const price = closes[closes.length-1];
          realDataMap[t.symbol] = {
            price, rsi, ema200, ema50, wt1, volSpike,
            priceVsEma200: ema200 ? parseFloat(((price/ema200-1)*100).toFixed(2)) : null,
            priceVsEma50: ema50 ? parseFloat(((price/ema50-1)*100).toFixed(2)) : null,
            type: 'stock'
          };
          stockDataCount++;
        }));
        if (i + DATA_BATCH < stockTickers.length) await new Promise(function(r) { setTimeout(r, 200); });
      }

      document.getElementById('loadingStatus').textContent = 'Real data fetched for ' + Object.keys(realDataMap).length + ' assets. Running AI analysis...';

      // Pre-filter using real data before sending to AI
      const qualified = [];
      Object.entries(realDataMap).forEach(function(entry) {
        const sym = entry[0], d = entry[1];
        let signals = [];
        if (d.wt1 !== null && d.wt1 < parseFloat(wtT)) signals.push('WaveTrend oversold (' + d.wt1 + ')');
        if (d.rsi !== null && d.rsi < parseFloat(rsiT)) signals.push('RSI oversold (' + d.rsi + ')');
        if (d.volSpike !== null && d.volSpike >= parseFloat(volT)) signals.push('Volume Spike ' + d.volSpike + 'x');
        if (d.ema200 !== null && d.priceVsEma200 !== null && Math.abs(d.priceVsEma200) <= 5) signals.push('Near 200 EMA (' + d.priceVsEma200 + '%)');
        if (signals.length >= parseInt(minT)) {
          qualified.push({ symbol: sym, data: d, signals });
        }
      });

      document.getElementById('loadingStatus').textContent = Object.keys(realDataMap).length + ' assets scanned. ' + qualified.length + ' qualify. Sending to AI for analysis...';

      // Send only qualified assets to AI with real data for interpretation
      const AI_BATCH = 15;
      let parsed = [];
      const mktLabel = marketsList;

      for (let b = 0; b < qualified.length; b += AI_BATCH) {
        const batch = qualified.slice(b, b + AI_BATCH);
        document.getElementById('loadingStatus').textContent = 'AI analysing batch ' + (Math.floor(b/AI_BATCH)+1) + ' of ' + Math.ceil(qualified.length/AI_BATCH) + '...';

        const dataLines = batch.map(function(q) {
          const d = q.data;
          return q.symbol + ': price=' + d.price + ', RSI=' + d.rsi + ', WT1=' + d.wt1 + ', VolSpike=' + d.volSpike + 'x, vs200EMA=' + d.priceVsEma200 + '%, signals=[' + q.signals.join(', ') + ']';
        }).join(' | ');

        const promptParts = [
          'You are a technical analyst. Today is ' + new Date().toDateString() + '.',
          'These assets have been pre-screened with REAL weekly data and qualify based on indicators.',
          'Real data: ' + dataLines,
          'For each asset write a 1-sentence analysis explaining WHY it is a setup based on the real numbers above.',
          'Return ONLY a raw JSON array. Format: [{"symbol":"BTC","market":"' + mktLabel + '","type":"crypto","score":' + parseInt(minT) + ',"signals":["RSI oversold (28)"],"wt1":-45.2,"rsi":28.1,"timeframe":"1W","analysis":"One sentence based on real data above."}]',
          'Include all ' + batch.length + ' assets. Do not skip any.'
        ];

        try {
          const response = await callAI(promptParts.join(' '));
          const clean = response.replace(/```json|```/gi,'').trim();
          const s = clean.indexOf('['), e = clean.lastIndexOf(']');
          if (s !== -1 && e !== -1) {
            const batchParsed = JSON.parse(clean.slice(s, e+1));
            // Override with real data values
            batchParsed.forEach(function(item) {
              const realD = realDataMap[item.symbol];
              if (realD) {
                item.wt1 = realD.wt1;
                item.rsi = realD.rsi;
                item.volSpike = realD.volSpike;
                item.price = realD.price;
              }
            });
            parsed = parsed.concat(batchParsed);
          }
        } catch(be) { console.log('AI batch error:', be); }

        if (b + AI_BATCH < qualified.length) await new Promise(function(r) { setTimeout(r, 300); });
      }

      // If no AI results but we have qualified assets, use them directly
      if (parsed.length === 0 && qualified.length > 0) {
        parsed = qualified.map(function(q) {
          return {
            symbol: q.symbol,
            market: mktLabel,
            type: q.data.type,
            score: q.signals.length,
            signals: q.signals,
            wt1: q.data.wt1,
            rsi: q.data.rsi,
            timeframe: '1W',
            analysis: 'Real data signals: ' + q.signals.join(', ') + '. Price: $' + q.data.price
          };
        });
      }

      // Fetch liquidation data from Binance if indicator selected
      let liqData = {};
      if (selectedInds.includes('Liquidation Zone')) {
        document.getElementById('loadingStatus').textContent='Fetching Binance liquidation data...';
        liqData = await fetchLiquidationData(allTickers);

        // Add liquidation signal to matching alerts
        allAlerts = allAlerts.map(a => {
          const liq = liqData[a.symbol];
          if (liq && liq.alert) {
            const dist = liq.alertType === 'NEAR_LONG_LIQ' ? liq.distToLongLiq : liq.distToShortLiq;
            const liqSignal = liq.alertType === 'NEAR_LONG_LIQ'
              ? 'üî¥ Long Liq Zone -' + dist + '%'
              : 'üü¢ Short Liq Zone -' + dist + '%';
            a.signals = [...(a.signals||[]), liqSignal];
            a.score = a.score + 1;
            a.analysis += ` Funding rate: ${(liq.fundingRate*100).toFixed(4)}% (${liq.fundingBias}).`;
          }
          return a;
        });

        // Add standalone liquidation alerts (not in AI results)
        Object.entries(liqData).forEach(([sym, d]) => {
          if (d.alert && !allAlerts.find(a => a.symbol === sym)) {
            allAlerts.push({
              symbol: sym,
              market: 'Crypto',
              type: 'crypto',
              score: 1,
              signals: [d.alertType === 'NEAR_LONG_LIQ' ? 'üî¥ Near Long Liq Zone' : 'üü¢ Near Short Liq Zone'],
              rsi: undefined,
              wt1: undefined,
              timeframe: '1W',
              analysis: `Price $${d.price} is near ${d.alertType === 'NEAR_LONG_LIQ' ? 'long' : 'short'} liquidation zone ($${d.alertType === 'NEAR_LONG_LIQ' ? d.longLiqZone : d.shortLiqZone}). Funding rate: ${(d.fundingRate*100).toFixed(4)}% ‚Äî ${d.fundingBias}.`
            });
          }
        });
      }

      // Fetch Reddit sentiment for alerted symbols
      let redditData = {};
      document.getElementById('loadingStatus').textContent='Fetching Reddit sentiment...';
      try {
        const alertedSymbols = allAlerts.map(a => ({ symbol: a.symbol, type: a.type || 'crypto' }));
        redditData = await fetchRedditSentiment(alertedSymbols);
        // Add sentiment to each alert
        allAlerts = allAlerts.map(a => {
          const r = redditData[a.symbol];
          if (r && r.posts > 0) {
            a.sentiment = r.label + ' (' + r.posts + ' posts, ' + r.upvotes + ' upvotes)';
            a.sentimentEmoji = r.emoji;
          }
          return a;
        });
      } catch(e) { console.log('Reddit error:', e); }

      document.getElementById('loadingStatus').textContent='Generating market summary...';

      const summaryPrompt=`Write a concise 3-sentence market summary for a trader covering ${marketsList} as of ${new Date().toDateString()}:
1. Overall market sentiment
2. Which sector looks most oversold/interesting
3. Key risk to watch
Be direct, specific, no disclaimers.`;

      const summary=await callAI(summaryPrompt);

      document.getElementById('loading').classList.remove('visible');
      document.getElementById('resultsSection').classList.add('visible');

      const strong=allAlerts.filter(a=>a.score>=3).length;
      document.getElementById('statTotal').textContent=allAlerts.length;
      document.getElementById('statStrong').textContent=strong;
      document.getElementById('statMod').textContent=allAlerts.length-strong;
      document.getElementById('statEngine').textContent=engineName;
      document.getElementById('aiSummaryText').textContent=summary;
      document.getElementById('aiSummary').classList.add('visible');

      allAlerts.sort((a,b)=>b.score-a.score);
      renderAlerts(allAlerts);

      // Send Telegram alerts
      if (document.getElementById('tgToken').value.trim()) {
        document.getElementById('loadingStatus').textContent='Sending Telegram alerts...';
        try {
          await sendTelegram(allAlerts, liqData);
          showToast('TELEGRAM ALERTS SENT ‚úì');
        } catch(e) {
          showToast('TELEGRAM ERROR: ' + e.message.substring(0,40));
        }
      }

    } catch(err) {
      showError('ERROR: ' + err.message);
      console.error(err);
    }
  }
</script>
</body>
</html>
